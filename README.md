# Л/Р 1 - Разработка класса
## Требования к сдаваемым работам

#### Структура класса - 50%
Класс содержит перечисленные пункты:
- конструктор по умолчанию;
- конструктор инициализации;
- конструктор копирования;
- поля класса, требуемые по условию задачи;
- методы доступа (селекторы и модификаторы) для скрытых (private) полей класса где это необходимо.

Если в классе окажутся открытые (public) поля, это должно быть обосновано.
Класс не допускает хранение ошибочных значений.

#### Тестирование - 20%
Тесты отвечают следующим требованиям:
- все тесты вызываются из функции main();
- для тестирования используется функция assert() из библиотеки assert.h;
- при отсутствии ошибок выводится сообщение об успешном прохождении тестов;
- вызов тестов должен управляться препроцессорной директивой ifdef;
- все функции в классе должны быть покрыты тестами (покрытие 100%);
- 
#### Оформление кода - 20%
Код программы выдержан в одном стиле, на протяжении всего кода программы, выбранные пользователем имена переменных придерживаются одного и того же стиля написания (например, UpperCamelCase для классов, lowerCamelCase для полей и методов, SCREAMING_SNAKE_CASE для констант). Имена переменных осмыслены, имена классов, методов и полей отражают их конкретную роль в программе (исключение: переменные в циклах, временные переменные).
Код разделен на заголовочные файлы (.h) и файлы реализации (.cpp).
Длины строк не превышают 80 символов (исключение: строки с комментариями).
Не используется потоковый ввод вывод в классе (соблюдение паттерна проектирования Model-View-Controller).

#### Эффективность кода - 10%
Методы, не изменяющие поля класса, объявлены как константные (подсказка: методы, возвращающие значения полей).
Ненужное копирование избегается передачей значений по ссылке (исключение: базовые типы данных (int, double, char, bool и т.п.)).
Нет дублирования кода.
Время обработки данных не превышает 0,5 секунды.

# Л/Р 2 - Наследование
## Требования к сдаваемым работам

#### Структура классов - 50%
Выполнены требования к структуре класса из л/р 1.
Правильно выполнено наследование - все общие для классов методы и поля правильно размещены в родительском классе, а уникальные – только в классах-наследниках.
В иерархии классов присутствует метод идентификации, метод является виртуальным, перегруженным в каждом наследнике и возвращающим различные значения в зависимости от класса.
#### Тестирование - 15%
Выполнены требования к тестированию из л/р 1.
Дополнительно тестируется консольный интерфейс.
#### Оформление кода - 25%
Выполнены требования к оформлению кода из л/р 1.
Дополнительно реализуется консольный интерфейс для взаимодействия пользователя с программой. Запуск взаимодействия (тесты или интерфейс командной строки) управляется препроцессорной директивой ifdef.
#### Эффективность кода - 10%
Выполнены требования к эффективности кода из л/р 1.
 
# Л/Р 3 - Использование хранилищ STL
## Требования к сдаваемым работам

#### Структура классов - 50%
Выполнены требования к структуре класса из л/р 2.
Корректно выбраны классы STL для решения поставленной задачи.
Создан класс, выполняющий поставленную задачу. Реализация обращения к внутреннему хранилищу является корректной и обоснованной.

#### Тестирование - 20%
Выполнены требования к тестированию из л/р 2.
Дополнительно тестируется корректность выполнения методов в зависимости от типа объекта.
Корректность выполняемых операций в соответствии с заданием.

#### Оформление кода - 20%
Выполнены требования к оформлению кода из л/р 2.

#### Эффективность кода - 10%
Выполнены требования к эффективности кода из л/р 2.
Дополнительно необходимо продемонстрировать объем используемой программой памяти. На пример с помощью psapi.h или аналога.
 
<!-- # Л/Р 4 – Реализация собственной коллекции с заданной структурой данных
## Требования к сдаваемым работам

#### Структура классов - 30%
Выполнены требования к структуре класса из л/р 3.
Класс-коллекция является шаблонным и соответствует своему варианту. Для хеш-таблиц разрешается использовать как свой, так и готовый алгоритм хеширования. 

Класс содержит перечисленные пункты:
- конструктор по умолчанию и конструктор копирования
- деструктор;
- метод, добавляющий в коллекцию заданное значение;
- оператор <<, добавляющий в коллекцию заданное значение;
- метод, удаляющий из коллекции заданное значение при его наличии;
- метод, удаляющий все хранящиеся значения из коллекции;
- метод, возвращающий количество хранящихся в коллекции значений;
- метод, принимающий ключ и возвращающий при его наличии в коллекции истину, а при отсутствии – ложь;
- оператор [], принимающий ключ и возвращающий его значение;
- оператор ==, принимающий другую коллекцию и возвращающий истину, если обе коллекции хранят одинаковые значения и ложь в противном случае;
- оператор &&, принимающий другую коллекцию и возвращающий все общие значения T в виде новой коллекции;
- метод, принимающий путь к файлу и сохраняющий в него содержимое коллекции;
- метод, принимающий путь к файлу и загружающий из него содержимое коллекции;
Класс устойчив к ошибкам и не позволяет хранить некорректные данные.
в деструкторе коллекции освобождается вся выделенная ей память;
публичные методы коллекции не принимают и не возвращают указатели на свои поля.
#### Графический интерфейс - 40%
Программа должна предоставлять пользователю выбор интерфейса: консольный или графический (через .bat файлы с аргументами запуска .exe файла).
В графическом интерфейсе необходимо проработать взаимодействие с пользователем (ввод/вывод данных, работа с файлами, эргономика).


#### Тестирование - 10%
Выполнены требования к тестированию из л/р 3.
Корректность выполняемых операций в соответствии с заданием.
#### Собственная реализация - 10%
Класс не использует готовые решения контейнеров (при этом разрешено использование готовых хеш-функций).
#### Эффективность кода - 10%
Выполнены требования к эффективности кода из л/р 3 -->
 
# Задание

1.	Коммивояжер продает конструкторы для умных детей. У элементов конструктора есть выпуклые соединители и вогнутые гнезда, в которые вставляются соединители. Элементы могут быть произвольной формы, которую можно описать в виде матрицы. Все углы у элемента прямые, высота всех элементов одинакова, позиции соединителей и гнезд совпадают. Необходимо научиться хранить схемы из таких элементов.
    1. Элемент: расположение соединителей и гнезд, проверка возможности занять часть или все соединители элементом.

    2. Умный элемент: элемент с дополнительным функционалом, который можно задействовать в схеме (автономная пищалка, датчик, мотор, … на выбор).

    3. Схема: трехмерная схема, проверяющая возможность расположения элементов по слоям.

    <!-- 4. Список схем. Ключ – размер схемы, значение – сама схема. (Коллекция – бинарное дерево) -->

